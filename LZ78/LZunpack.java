//Written by Tony Shu (ID:1356141) and Jiwei Wang (ID:1360206)

import java.io.File;
import java.io.FileWriter;
import java.util.Scanner;

//given the output from LZpack
//this program will uncompress it and generate output which is exactly the same as the input to LZpack
public class LZunpack
{
    public static void main(String[] args)
    {
        //create a temporary file for data storage (stores data in binary representation)
        File file=new File("temp1");
        //convert the compressed byte values to its binary representation
        byteToBinary(file);
        //convert the binary representation to the original input to the LZpack
        binaryToOriginal();
        //delete the temporary file as it's no longer needed no more
        file.delete();
    }

    //this method read standard input, which is the output generated by LZpack
    //convert it to compressed binary representation and stores the result in a temporary file
    //which matches the binary representation stored in the temporary file from LZpack
    //takes one parameter:
    //File file: the temporary file that stores the output of this method
    public static void byteToBinary(File file)
    {
        try
        {
            //declare variables
            int digitNum=8;
            FileWriter myWriter = new FileWriter(file);
            int byteValue;
            int next;
            int last;


            //as long as there is more input coming
            while ((byteValue=System.in.read())!=-1)
            {
                //special case handling:
                //digitNum is 8 in default, as a byte value consists of 8 bits
                //if the current byte being read represents the number of digits of the last byte
                //e.g. the second last byte value (please refer to the comments in LZpack if you are confused)
                //then reset the value of digitNum

                //mark the current position in the input stream
                System.in.mark(0);
                //read the next two bytes of the current byte being read(byteValue)
                next=System.in.read();
                last=System.in.read();

                //if the current byte value represents the number of digits of the last byte
                if(last==-1)
                {
                    //set the digit number to the value of the current byte
                    digitNum=byteValue;
                    int input=Integer.valueOf(next);
                    String binary = String.format("%"+digitNum+"s", Integer.toBinaryString(input & 0xFF)).replace(' ', '0');
                    myWriter.write(binary);
                    break;
                }
                else
                {
                    //otherwise we are handling general cases
                    //simply print the output
                    int input=Integer.valueOf(byteValue);
                    String binary = String.format("%"+digitNum+"s", Integer.toBinaryString(input & 0xFF)).replace(' ', '0');
                    myWriter.write(binary);
                    //fixes the position at the last marked position so that same byte can be read again.
                    System.in.reset();
                }

            }
            //close input reader and output writer
            myWriter.close();

        }
        catch (Exception e)
        {
            System.err.println(e);
        }

    }

    //this method convert the compressed binary representation
    //to the original input to LZpack
    public static void binaryToOriginal()
    {
        try
        {
            //declare variables
            File f = new File("temp1");
            Scanner sc = new Scanner(f);
            sc.useDelimiter("");

            int charOrPhrase=0;
            int phraseNum=0;
            int bitNum;
            String binary;
            int result;

            //as long as there is more input coming
            while(sc.hasNext())
            {
                //if we are dealing with phrase numbers
                if(charOrPhrase%2==0)
                {
                    //calculate the number of bits needed for revert the phrase number
                    double i=Math.log(phraseNum) / Math.log(2)+ 1e-10;
                    bitNum=(int)Math.ceil(i);

                    if(i>0)
                    {
                        binary=grabBinary(sc,bitNum);
                        result = Integer.parseInt(binary, 2);
                        System.out.print(result+" ");
                    }
                    else
                    {
                        //LZpack has 0 bit to represent the phrase number of the first tuple
                        //so we don't need to read any bits as well
                        int start=0;
                        System.out.print(start+" ");
                    }
                    phraseNum++;
                }
                //otherwise we are dealing with mismatched characters
                else
                {
                    //read 8 bits at a time
                    //convert the result to the original byte values
                    binary=grabBinary(sc,8);
                    result = Integer.parseInt(binary, 2);
                    byte b=(byte)result;
                    System.out.print(b+"\n");
                }
                charOrPhrase++;

            }
            //close input reader
            sc.close();

        }
        catch (Exception e)
        {
            System.err.println(e);
        }

    }

    //this method read a specific number of bits at a time from the temporary file
    //return the result as a string
    //takes two parameters:
    //Scanner sc: used for reading input from the temporary file
    //int digits: specify how many number of bits is needed
    public static String grabBinary(Scanner sc,int digits)
    {
        //declare variables
        String result="";
        int counter=0;

        //as long as we have not reached the end of input
        while(sc.hasNext())
        {
            //get the result and return it as a string
            if(counter<digits)
            {
                result+=sc.next();
                counter++;
            }
            else
            {
                break;
            }
        }

        return result;
    }
}
